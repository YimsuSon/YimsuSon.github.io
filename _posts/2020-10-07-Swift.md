---
title: 1.iOS Basic, Label and Button 만들기
excerpt: iOS-Swift


#최상위 사진
header:
  image: /assets/images/foo-bar-identity.jpg
  teaser: /assets/images/foo-bar-identity-th.jpg

gallery:
  - url: /assets/images/unsplash-gallery-image-1.jpg
    image_path: assets/images/unsplash-gallery-image-1-th.jpg
    alt: "placeholder image 1"
  - url: /assets/images/unsplash-gallery-image-2.jpg
    image_path: assets/images/unsplash-gallery-image-2-th.jpg
    alt: "placeholder image 2"
  - url: /assets/images/unsplash-gallery-image-3.jpg
    image_path: assets/images/unsplash-gallery-image-3-th.jpg
    alt: "placeholder image 3"
    


 #사이드바 설정 
sidebar:
  - title: "Role"
    nav: sidebar-sample

# 해당 글 목차
toc: true
toc_sticky: true

toc_label: "Yimsu's Blog"
toc_icon: "cog"


## 테그설정

categories:
  - iOS

tags:
  - iOS-Swift
  - "2020"
  - "2020.10"



---

- Object = 데이터 + 메서드 

<br/>

### 1.  Tuple 

<br/>
SwiftExpression


``` swift
Tuple
(Tuple member1,Tuple member2, ...)
tuple.0

Named Tuple
(name1: expr1, name2: expr2)
tuple.membername

Tuple Decomposition
let name = (mem1,mem2,mem3)
let (mem1,mem2,mem3) = name
``` 

<br/>

ex) 
``` swift
let coordinateNamed = (x:2, second:3)
 
// 하나씩 가져오기
 
let x2 = coordinateNamed.x
let y2 = coordinateNamed.second
 
//한번에 가져오기
 
let (x3,y3) = coordinateNamed
x3
y3
```


### 2. Boolean

ex)
``` swift
let name1 = "Jin"
let name2 = "Jason"
 
let isTwoNameSame = name1 == name2
 
if isTwoNameSame {
    print("wow")
} else {
    print("diffent")
}
```


### 3. FlowContorl 
- 건너 뛰어야 되는 상황, 반복적으로 해야되는 상황
- if else 구문 , for 구문, while statement, switch statement

<br/>

SwiftExpression


``` swift
// 삼항 연산자

조건 ? 참 : 거짓
let a:String = b ? "True" : "False"

// 


// while statement => 조건검사 후 코드수행
var i = 0
while i < 10 {
    print(i)
    if i == 5 {
        break
    }
    i += 1
}


// repeat while statement =>  코드수행 후 조건검사
var ii = 0
repeat {
    print(ii)
    ii += 1
} while ii < 10


// where statement => for 문에서 조건을 넣는 문법 swift 제공
for i in zeroTotenn where i % 2 == 0 {
    print("--> where 짝수 :\(i)")
}

// Switch Statement
let num = 8
 
switch num {
case 0:
    print("--> 0")
case 0...5:
    print("--> 0에서 5구간 ")
case 6,7:
    print("--> 6 이거나 7")
case _ where num % 2 == 0:
    print("-->짝수")
default:
    print("-->나머지")
}


```

<br/>


ex)
``` swift 
let man1 = "a"
let man2 = "b"

let isMan = man2 == "b"
let isMale = true

// 둘다 ture 면 true
let man1Andman2 = isMan && isMale

// 둘중 하나라도 true 면 true
let man1Orman2 = isMans || isMale

```


### 3.Function and Optional

- Funtion = 기능수행

- Method = object에 속해서 기능수행


SwiftExpression


``` swift

func functionName(ArgumentLabel parameter: ParameterType) -> ReturnType {
    return returnValue
}

```

- Overload = 같은 이름 다른 행동

ex)

``` swift 
func printTotalPrice(price:Int, count: Int) {
    print("Total Price : \(price * count)")
}
 
func printTotalPrice(price:Double, count: Double) {
    print("Total Price : \(price * count)")
}
```


- In-out parameter
    - parameter는 복사해서 들어오는 constant 이다, 이것을 변경하고 싶을때 In-out parameter를 사용

ex)

``` swift
var value = 3
func a(_ value:inout Int){
    value += 1
    print(value)
}

a(&value)

```

### 4. Optional 
- 값이 있을 수도 있고 없을 수도 있는것
- Optional 4가지 해제방법 F i N g
    - 1. Forced unwarpping -> 값이 있는 경우 강제로 옵셔널을 해제하여 값을 가지고 오는방법, 오류에 대한 대비가 없는 강제추출이므로 오류발생가능성
    - 2. Optional binding (if let) -> 부드럽게 옵셔널 해제, 오류발생가능성 낮음
    - 3. Optional binding (guard) -> 부드럽게 옵셔널 해제, 오류발생가능성 낮음 (if 로인한 cyclomatic complexity를 낮춰준다)
    - 4. Nil coalescing -> 해제를 했는데 nil 인경우 default 값을 준다 , 중고거래 벽돌 택배거래



ex)

``` swift
//1. Forced unwarpping
var carName: String?
carName = nil
carName = "땡크"
 
print(carName)
print(carName!)






// 2. Optional binding (if let)
var carName: String?
carName = nil
carName = "땡크"
 
if let unwrappedCarName = carName {
    print(unwrappedCarName)
} else {
    print("Car Name 없다")
}
 
 
func printParsedInt(from: String){
    if let parsedInt = Int(from) {
        print(parsedInt)
    } else {
        print("Int로 컨버팅 안된다 짜샤")
    }
}
printParsedInt(from: "100")
printParsedInt(from: "ㅗㅜㅑ")


// 3. Optional binding (guard let) -> 부드럽게 옵셔널 해제, 오류발생가능성 낮음 , comlpexity를 줄인다
 
func printParsedInt2(from: String) {
    guard let parsedInt = Int(from) else {
        print("Int로 컨버팅 x")
        return
    }
    print(parsedInt)
}
 
printParsedInt2(from: "Hi")


// 4 Nil coalescing -> 해제를 했는데 nil 인경우 default 값을 준다 , 중고거래 벽돌 택배거래
 
var carName: String?
carName = nil
let myCarName: String = carName ?? "테슬라" // ?? 를 통해서 carName 이 nil 일 경우 "테슬라"를 default value 로 넘겨줘라

```


SwiftExpression
``` swift
guard statement

func a() {
    guard let expression else{
        false code
        return
    } else {
        true code
    }
}


var name : String? = "aaa"
func printNickName(name: String?) {
    guard let a = name else {
        print("name 없다")
        return
    }
    
    print(a)
}
printNickName(name:"g")

```


### 5. Collection
- Array - 어레이는 순탄하네
    - 순서가 있다
    - 같은 타입만 담는다


ex)

``` swift
//Array 선언1
var evenNumbers: [Int] = [2, 4, 6, 8]
//Array 선언2
var evenNumbers2: Array<Int> = [2, 4, 6, 8]
 
// .append 프로퍼티 => 추가
evenNumbers2.append(10)
evenNumbers2 += [12,23,14]
evenNumbers2.append(contentsOf: [10,20])
 
// .isEmpty => 비어있으면 true
let isEmpty = evenNumbers2.isEmpty
 
// .count array 안의 개수 확인
evenNumbers2.count
 
// .first 첫번째
// .last 마지막
// 두번째
evenNumbers2[2]
 
// .min .max
print(evenNumbers.first)
 
let firstItem = evenNumbers.first // Int Optional 인 이유는  evenNumbers 가 없을수도 있기 때문
 
if let firstItem = evenNumbers.first {
    print("--> first item is :\(firstItem)")
}



``` 

- Dictionary
    - Key : Value
    - 의미단위로 찾을때
    - 순서가 없다


SwiftExpression
``` swift
//Array 선언1
var evenNumbers: [Int] = [2, 4, 6, 8]
//Array 선언2
var evenNumbers2: Array<Int> = [2, 4, 6, 8]


// Set 표현
var someArray: [Int] = [1,2,2]
var someSet: Set<Int> = [1,2,3,1]


// Dictionary
// 표현방법 1
var scoreDic: [String:Int] = ["Jason":80, "Jay":95, "Jake": 25]
// 표현방법 2
var scoreDic2: Dictionary<String,Int> = ["Jason":80, "Jay":95, "Jake": 25]

scoreDic["Jason"]
scoreDic["Jay"]
scoreDic["J"]
 
if let score = scoreDic["Jay"] {
    score
} else {
    // score 없음
}
 
// scoreDic = [:] 전체제거
scoreDic.isEmpty
 
// 값 업데이트
scoreDic["Jason"] = 99
scoreDic



```

- Closure
    - 이름이 없는 함수
    - 생략순서 매개변수 $ return => 매$리


SwiftExpression
``` swift

// Closer
var multiplyClosure: (Int,Int) -> Int = {
    (a:Int, b:Int) -> Int in
    return a + b
}
 
// Closer 생략 타입 - 매$리
 
// 1. 매개변수 생략
var multiplyClosure1: (Int,Int) -> Int = { a, b -> Int in
    return a + b
}
// 2. $사용
var multiplyClosure2: (Int,Int) -> Int = { return $0 + $1 }
 
// 3. return 생략
var multiplyClosure3: (Int,Int) -> Int = { $0 + $1 }
 
let result = multiplyClosure(4,2)



// closure 를 받는 function

func operateTwoNum(a:Int, b:Int, oper:(Int,Int) -> Int) -> Int {
    let result = oper(a,b)
}
operateTwoNum(a:4, b:2, oper:multiplyClouser)


// closure 를 받는 function2 

var addClosure : (Int,Int) -> Int = { a, b in
return a+b
}
operateTwoNum(a:5,b:6, oper: addClousure)


```

